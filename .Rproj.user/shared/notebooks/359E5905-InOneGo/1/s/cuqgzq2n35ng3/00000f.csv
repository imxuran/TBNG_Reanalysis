"0",""
"0","## Function for WGCNA"
"0","wgcna <- function(df, n) {"
"0","  "
"0","  df_raw <- df"
"0",""
"0","  df <- scale(df[, analy_traits])"
"0","  "
"0","  #rownames(df) <- df_raw$SampleID"
"0","  "
"0","  ### Determine Soft Thresholding Power"
"0","  # Choosing a soft-threshold to fit a scale-free topology to the network"
"0","  powers = c(c(1:10), seq(from = 12, to=20, by=2))"
"0","  "
"0","  # Call the network topology analysis function"
"0","  sft=pickSoftThreshold(df, dataIsExpr = TRUE, powerVector = powers, corFnc = bicor, networkType = ""unsigned"")"
"0","  "
"0","  softPower = which.max(-sign(sft$fitIndices[,3])*sft$fitIndices[,2])"
"0","  "
"0","  "
"0","  # Plot the soft cutoff results"
"0","  sizeGrWindow(9, 5)"
"0","  par(mfrow = c(1,2))"
"0","  "
"0","  # Scale-free topology fit index as a function of the soft-thresholding power"
"0","  plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],"
"0","       xlab=""Soft Threshold (power)"", ylab=""Scale Free Topology Model Fit, signed R^2"",type=""n"", "
"0","       main = paste(""Scale independence -"",n))"
"0","  text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], "
"0","       labels=powers, cex=0.9, col=""red"")"
"0","  "
"0","  abline(h=0.80,col=""red"")  # Red line corresponds to using an R^2 cut-off"
"0","  "
"0","  "
"0","  # Mean connectivity as a function of the soft-thresholding power"
"0","  plot(sft$fitIndices[,1], sft$fitIndices[,5],"
"0","       xlab=""Soft Threshold (power)"", ylab=""Mean Connectivity"", type=""n"","
"0","       main = paste(""Mean connectivity -"",n))"
"0","  text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=0.9,col=""red"")"
"0","  "
"0","  "
"0","  "
"0","  ### Generating adjacency and TOM similarity matrices based on the selected softpower"
"0","  #calclute the adjacency matrix"
"0","  adj= adjacency(df, type = ""unsigned"", power = softPower)"
"0","  "
"0","  #turn adjacency matrix into topological overlap to minimize the effects of noise and spurious associations"
"0","  TOM=TOMsimilarity(adj)"
"0","  "
"0","  colnames(TOM) = rownames(TOM) = colnames(df)"
"0","  dissTOM=1-TOM"
"0","  "
"0","  #hierarchical clustering of the genes based on the TOM dissimilarity measure"
"0","  geneTree = hclust(as.dist(dissTOM), method = ""average"")"
"0","  "
"0","  # Module identification using dynamic tree cut"
"0","  dynamicMods = cutreeDynamic(dendro = geneTree,  method=""tree"", minClusterSize = 5)"
"0","  dynamicColors = labels2colors(dynamicMods)"
"0","  "
"0","  png(paste0(""../Results/WGCNA/individual/"",n,""_dendrogram.png""), width = 2500, height = 1600, res = 300)"
"0","  "
"0","  plotDendroAndColors(geneTree, dynamicColors, ""Dynamic Tree Cut"", dendroLabels = NULL, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = paste(""Dendrogram and module colors -"",n))"
"0","  "
"0","  dev.off()"
"0","  "
"0","  "
"0","  "
"0","  ### Which modules have biggest differences across treatment groups"
"0","  module_eigengenes <- moduleEigengenes(df, colors = dynamicColors)$eigengenes"
"0","  # Create the design matrix from the `group` variable"
"0","  des_mat <- model.matrix(~ df_raw$group)"
"0","  fit <- limma::lmFit(t(module_eigengenes), design = des_mat)"
"0","  # Apply empirical Bayes to smooth standard errors, very practical in our case"
"0","  fit <- limma::eBayes(fit)"
"0","  # Apply multiple testing correction and obtain stats in a single object"
"0","  stats_df <- limma::topTable(fit, number = ncol(module_eigengenes)) %>% tibble::rownames_to_column(""module"")"
"0","  "
"0","  # exploring moduls"
"0","  ME_df <- cbind(module_eigengenes,df_raw['group'])"
"0","  "
"0","  stats_df <- stats_df %>%"
"0","    dplyr::filter(module != ""ME0"" & module != ""MEgrey"") %>%"
"0","    dplyr::arrange(adj.P.Val)"
"0","  "
"0","  if (nrow(stats_df) == 0) {"
"0","    # Case: Only ME0 exists"
"0","    print(""No modules identified!"")"
"0","  } else {"
"0","    top_module <- stats_df$module[1]"
"0","    "
"0","    # Get a vector of variables IDs that correspond to this (most significant) module"
"0","    module_genes <- colnames(df)[dynamicColors == substr(top_module, 3, nchar(top_module))]"
"0","    "
"0","    "
"0","    # a visual support"
"0","    p1 <- ggplot(ME_df, aes(x = group, y = !!sym(top_module), color = group)) + geom_boxplot(width = 0.2, outlier.shape = NA) + ggforce::geom_sina(maxwidth = 0.3) + theme_classic()"
"0","    "
"0","    p2 <- make_module_heatmap(module_name = substr(top_module, 3, nchar(top_module)), expression_mat = df, metadata_df = df_raw, module_gene = module_genes, module_eigengenes_df = module_eigengenes)"
"0","    "
"0","    png(paste0(""../Results/WGCNA/individual/"",n,""_heatmap.png""), width = 4500, height = 2300, res = 300)"
"0","    "
"0","    grid.arrange(p1, grid.grabExpr(draw(p2)), ncol = 2,"
"0","                 top = textGrob(n, gp = gpar(fontsize = 16, font = 2)))"
"0","    "
"0","    dev.off()"
"0","    "
"0","    return(module_genes)"
"0","  }"
"0","}"
"0",""
"0",""
