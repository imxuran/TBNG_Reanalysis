"0","# Generalized contrastive PCA (gcPCA) function"
"0","gcPCA <- function(Ra, Rb, method = 'v4', Ncalc = Inf, Nshuffle = 0, normalize_flag = TRUE,"
"0","                  alpha = 1, alpha_null = 0.975, cond_number = 1e13, verbose = TRUE) {"
"0","  "
"0","  # Internal function to normalize data using L2 norm (Euclidean)"
"0","  normalize <- function(data) {"
"0","    data <- scale(data) # Center and scale columns"
"0","    data <- data / norm(data, type = ""2"") # Normalize overall L2 norm"
"0","    return(data)"
"0","  }"
"0","  "
"0","  inspect_inputs <- function(Ra, Rb) {"
"0","    if (ncol(Ra) != ncol(Rb)) stop(""Ra and Rb must have the same number of features"")"
"0","    "
"0","    if (normalize_flag) {"
"0","      Ra <- normalize(Ra)"
"0","      Rb <- normalize(Rb)"
"0","    }"
"0","    "
"0","    # Determine how many gcPCs can be computed (limited by data rank)"
"0","    n_gcpcs <- min(nrow(Ra), nrow(Rb))"
"0","    RaRb <- rbind(Ra, Rb)"
"0","    svd_result <- svd(RaRb)"
"0","    Sab <- svd_result$d"
"0","    tol <- max(dim(RaRb)) * .Machine$double.eps * max(Sab)"
"0","    "
"0","    if (sum(Sab > tol) < n_gcpcs) {"
"0","      warning(""Input data is rank-deficient! Discarding dimensions."")"
"0","      n_gcpcs <- sum(Sab > tol)"
"0","    }"
"0","    "
"0","    # Basis vectors for projection (top right singular vectors)"
"0","    J <- svd_result$v[, 1:n_gcpcs, drop = FALSE]"
"0","    "
"0","    if (method %in% c('v2.1', 'v3.1', 'v4.1')) {"
"0","      n_gcpcs <- min(Ncalc, n_gcpcs)"
"0","      if (verbose) message(n_gcpcs, "" gcPCs will be returned."")"
"0","    }"
"0","    "
"0","    list(n_gcpcs = n_gcpcs, J = J, Ra = Ra, Rb = Rb)"
"0","  }"
"0","  "
"0","  # Core gcPCA computation"
"0","  fit <- function(Ra, Rb) {"
"0","    inspected <- inspect_inputs(Ra, Rb)"
"0","    Ra <- inspected$Ra; Rb <- inspected$Rb"
"0","    J <- inspected$J"
"0","    n_gcpcs <- inspected$n_gcpcs"
"0","    "
"0","    # Compute covariance matrices"
"0","    RaRa <- crossprod(Ra) / (nrow(Ra) - 1)"
"0","    RbRb <- crossprod(Rb) / (nrow(Rb) - 1)"
"0","    "
"0","    # --- Simple contrastive version ---"
"0","    if (method == 'v1') {"
"0","      JRaRaJ <- t(J) %*% RaRa %*% J"
"0","      JRbRbJ <- t(J) %*% RbRb %*% J"
"0","      sigma <- JRaRaJ - alpha * JRbRbJ"
"0","      eig <- eigen(sigma, symmetric = TRUE)"
"0","      w <- eig$values"
"0","      v <- eig$vectors"
"0","      eig_idx <- order(w, decreasing = TRUE)"
"0","      x <- J %*% v[, eig_idx]"
"0","      s_total <- w[eig_idx]"
"0","      obj_info <- 'Ra - alpha * Rb'"
"0",""
"0","      # --- Generalized contrastive PCA versions ---      "
"0","    } else {"
"0","      denom_well_conditioned <- FALSE"
"0","      ortho_column_order <- c()"
"0","      count_dim <- 0"
"0","      x <- NULL"
"0","      x_orth <- NULL"
"0","      "
"0","      # Iterate to extract components one by one"
"0","      for (idx in 1:n_gcpcs) {"
"0","        JRaRaJ <- t(J) %*% RaRa %*% J"
"0","        JRbRbJ <- t(J) %*% RbRb %*% J"
"0","        "
"0","        # Define numerator and denominator for generalized Rayleigh quotient"
"0","        if (method %in% c('v2', 'v2.1')) {"
"0","          numerator <- JRaRaJ; denominator <- JRbRbJ"
"0","          obj_info <- 'Ra / Rb'"
"0","        } else if (method %in% c('v3', 'v3.1')) {"
"0","          numerator <- JRaRaJ - JRbRbJ; denominator <- JRbRbJ"
"0","          obj_info <- '(Ra-Rb) / Rb'"
"0","        } else if (method %in% c('v4', 'v4.1')) {"
"0","          numerator <- JRaRaJ - JRbRbJ; denominator <- JRaRaJ + JRbRbJ"
"0","          obj_info <- '(Ra-Rb) / (Ra+Rb)'"
"0","        } else stop(""Unrecognized method."")"
"0","        "
"0","        if (!denom_well_conditioned) {"
"0","          if (kappa(denominator) > cond_number) {"
"0","            warning(""Denominator ill-conditioned. Regularizing."")"
"0","            w <- eigen(denominator, symmetric = TRUE)$values"
"0","            alpha <- max(w[1] / cond_number - tail(w, 1), 0)"
"0","            denominator <- denominator + diag(nrow(denominator)) * alpha"
"0","          }"
"0","          denom_well_conditioned <- TRUE"
"0","        }"
"0","        "
"0","        # Whitening the denominator"
"0","        eig_den <- eigen(denominator, symmetric = TRUE)"
"0","        d <- eig_den$values"
"0","        d[d < 0] <- 0"
"0","        e <- eig_den$vectors"
"0","        M <- e %*% diag(sqrt(d)) %*% t(e)"
"0","        Minv <- tryCatch(solve(M), error = function(e) solve(M + diag(nrow(M)) * 1e-6))"
"0","        sigma <- t(Minv) %*% numerator %*% Minv"
"0","        "
"0","        # Solve eigenproblem in transformed space"
"0","        eig <- eigen(sigma, symmetric = TRUE)"
"0","        w <- eig$values"
"0","        v <- eig$vectors"
"0","        eig_idx <- order(w, decreasing = TRUE)"
"0","        v <- v[, eig_idx]"
"0","        x_temp <- J %*% Minv %*% v"
"0","        x_temp <- x_temp / norm(x_temp, type = ""2"")"
"0","        "
"0","        # Orthogonalize and select directions"
"0","        if (idx == 1) {"
"0","          x <- x_temp"
"0","          x_orth <- matrix(x_temp[, 1], ncol = 1)"
"0","          ortho_column_order <- c(ortho_column_order, count_dim)"
"0","          count_dim <- count_dim + 1"
"0","        } else {"
"0","          if (idx %% 2 == 1) {"
"0","            x_add <- matrix(x_temp[, ncol(x_temp)], ncol = 1)"
"0","            ortho_column_order <- c(ortho_column_order, ncol(x_temp) + count_dim - 1)"
"0","          } else {"
"0","            x_add <- matrix(x_temp[, 1], ncol = 1)"
"0","            ortho_column_order <- c(ortho_column_order, count_dim)"
"0","            count_dim <- count_dim + 1"
"0","          }"
"0","          x_orth <- cbind(x_orth, x_add)"
"0","        }"
"0","        "
"0","        if ((ncol(J) - ncol(x_orth)) < 1) break  # avoid shrinking to zero cols"
"0","        j <- svd(J - x_orth %*% t(x_orth) %*% J)$u"
"0","        J <- j[, 1:(ncol(J) - 1), drop = FALSE]"
"0","      }"
"0","      "
"0","      if (method %in% c('v2.1', 'v3.1', 'v4.1')) {"
"0","        new_column_order <- order(ortho_column_order)"
"0","        x <- x_orth[, new_column_order, drop = FALSE]"
"0","      }"
"0","      "
"0","      # Compute scores and objective values"
"0","      RaX <- Ra %*% x"
"0","      RbX <- Rb %*% x"
"0","      XRaRaX <- crossprod(RaX)"
"0","      XRbRbX <- crossprod(RbX)"
"0","      "
"0","      if (method %in% c('v2', 'v2.1')) {"
"0","        numerator_orig <- XRaRaX; denominator_orig <- XRbRbX"
"0","      } else if (method %in% c('v3', 'v3.1')) {"
"0","        numerator_orig <- XRaRaX - XRbRbX; denominator_orig <- XRbRbX"
"0","      } else if (method %in% c('v4', 'v4.1')) {"
"0","        numerator_orig <- XRaRaX - XRbRbX; denominator_orig <- XRaRaX + XRbRbX"
"0","      }"
"0","      "
"0","      s_total <- diag(numerator_orig) / diag(denominator_orig)"
"0","    }"
"0","    "
"0","    # Return loadings, scores, and diagnostics"
"0","    list(loadings = x,"
"0","         Ra_scores = Ra %*% x / norm(Ra %*% x, type = ""2""),"
"0","         Ra_values = norm(Ra %*% x, type = ""2""),"
"0","         Rb_scores = Rb %*% x / norm(Rb %*% x, type = ""2""),"
"0","         Rb_values = norm(Rb %*% x, type = ""2""),"
"0","         objective_function = obj_info,"
"0","         objective_values = s_total,"
"0","         null_gcpca_values = if (Nshuffle > 0) null_distribution(Ra, Rb) else NULL)"
"0","  }"
"0","  "
"0","  null_distribution <- function(Ra, Rb) {"
"0","    null_vals <- NULL"
"0","    for (i in 1:Nshuffle) {"
"0","      Ra_shuf <- Ra[sample(nrow(Ra)), ]"
"0","      Rb_shuf <- Rb[sample(nrow(Rb)), ]"
"0","      fit_result <- fit(Ra_shuf, Rb_shuf)"
"0","      null_vals <- rbind(null_vals, fit_result$objective_values)"
"0","    }"
"0","    null_vals"
"0","  }"
"0","  "
"0","  fit(Ra, Rb)"
"0","}"
