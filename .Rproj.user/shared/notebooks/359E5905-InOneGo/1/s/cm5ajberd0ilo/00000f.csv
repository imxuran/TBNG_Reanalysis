"0",""
"0","### Function of consensus WGCNA (to detect the shared modules in multiple datasets)"
"0",""
"0","consensus_wgcna <- function(df_list, n) {"
"0","  "
"0","  df_raw_list <- df_list"
"0","  "
"0","  for (i in 1:length(df_list)) {"
"0","    df_list[[i]] <- list("
"0","      data = as.data.frame(scale(df_list[[i]][, analy_traits]))"
"0","    )"
"0","  }"
"0","  "
"0","  consensusModules <- blockwiseConsensusModules(df_list, power = 6, minModuleSize = 5,  networkType = ""unsigned"")"
"0","  "
"0","  png(paste0(""../Results/WGCNA/consensus/"",n,""_dendrogram.png""), width = 2500, height = 1600, res = 300)"
"0","  "
"0","  plotDendroAndColors("
"0","    dendro = as.hclust(consensusModules$dendrograms[[1]]),"
"0","    colors = cbind(consensusModules$colors),"
"0","    groupLabels = ""Consensus modules"","
"0","    main = paste(""Consensus gene dendrogram and module colors -"", n),"
"0","    dendroLabels = analy_traits,"
"0","    hang = 0.03,"
"0","    addGuide = TRUE,"
"0","    guideHang = 0.05"
"0","  )"
"0","  "
"0","  dev.off()"
"0","  "
"0","  consensus_kME <- consensusKME(df_list, moduleLabels = consensusModules$colors, multiEigengenes = consensusModules$multiMEs)"
"0","  "
"0","  "
"0","  ### Which modules have biggest differences across treatment groups"
"0","  for (n in names(df_raw_list)) {"
"0","    "
"0","    df_raw <- df_raw_list[[n]]"
"0","    module_eigengenes <- consensusModules$multiMEs[[n]]$data"
"0","    dynamicColors <- consensusModules$colors"
"0","    "
"0","    # Create the design matrix from the `group` variable"
"0","    des_mat <- model.matrix(~ df_raw$group)"
"0","    fit <- limma::lmFit(t(module_eigengenes), design = des_mat)"
"0","    # Apply empirical Bayes to smooth standard errors, very practical in our case"
"0","    fit <- limma::eBayes(fit)"
"0","    # Apply multiple testing correction and obtain stats in a single object"
"0","    stats_df <- limma::topTable(fit, number = ncol(module_eigengenes)) %>% tibble::rownames_to_column(""module"")"
"0","    "
"0","    # exploring moduls"
"0","    ME_df <- cbind(module_eigengenes,df_raw['group'])"
"0","    "
"0","    stats_df <- stats_df %>%"
"0","      dplyr::filter(module != ""ME0"" & module != ""MEgrey"") %>%"
"0","      dplyr::arrange(adj.P.Val)"
"0","    "
"0","    if (nrow(stats_df) == 0) {"
"0","      # Case: Only ME0 exists"
"0","      print(""No modules identified!"")"
"0","    } else {"
"0","      top_module <- stats_df$module[1]"
"0","      "
"0","      # Get a vector of variables IDs that correspond to this (most significant) module"
"0","      module_genes <- names(dynamicColors)[dynamicColors == substr(top_module, 3, nchar(top_module))]"
"0","      "
"0","      "
"0","      # a visual support"
"0","      p1 <- ggplot(ME_df, aes(x = group, y = !!sym(top_module), color = group)) + geom_boxplot(width = 0.2, outlier.shape = NA) + ggforce::geom_sina(maxwidth = 0.3) + theme_classic()"
"0","      "
"0","      p2 <- make_module_heatmap(module_name = substr(top_module, 3, nchar(top_module)), expression_mat = df, metadata_df = df_raw, module_gene = module_genes, module_eigengenes_df = module_eigengenes)"
"0","      "
"0","      png(paste0(""../Results/WGCNA/consensus/"",n,""_heatmap.png""), width = 4500, height = 2300, res = 300)"
"0","      "
"0","      grid.arrange(p1, grid.grabExpr(draw(p2)), ncol = 2,"
"0","                   top = textGrob(n, gp = gpar(fontsize = 16, font = 2)))"
"0","      "
"0","      dev.off()"
"0","      "
"0","    }"
"0","    "
"0","  }"
"0","  "
"0","  return(consensus_kME)"
"0","}"
